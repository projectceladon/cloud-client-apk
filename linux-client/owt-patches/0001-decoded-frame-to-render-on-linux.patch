From 7743684a8d15078aa69ed0df5cce27484ff134dc Mon Sep 17 00:00:00 2001
From: Some One <someone@somewhere.com>
Date: Fri, 15 Apr 2022 11:29:53 +0800
Subject: [PATCH] decoded frame to render on linux

Signed-off-by: Some One <someone@somewhere.com>
---
 .../sdk/base/customizedvideodecoderproxy.cc   | 45 ++++++++++++++++---
 .../sdk/base/customizedvideodecoderproxy.h    |  6 +++
 talk/owt/sdk/base/stream.cc                   |  2 -
 talk/owt/sdk/include/cpp/owt/base/stream.h    |  2 -
 .../cpp/owt/base/videodecoderinterface.h      |  9 +++-
 5 files changed, 54 insertions(+), 10 deletions(-)

diff --git a/talk/owt/sdk/base/customizedvideodecoderproxy.cc b/talk/owt/sdk/base/customizedvideodecoderproxy.cc
index 6fef4ee..320cd87 100644
--- a/talk/owt/sdk/base/customizedvideodecoderproxy.cc
+++ b/talk/owt/sdk/base/customizedvideodecoderproxy.cc
@@ -4,12 +4,16 @@
 #include "talk/owt/sdk/base/customizedvideodecoderproxy.h"
 #include "talk/owt/sdk/include/cpp/owt/base/commontypes.h"
 #include "talk/owt/sdk/include/cpp/owt/base/videodecoderinterface.h"
+#include "third_party/libyuv/include/libyuv/convert.h"
+#include "webrtc/rtc_base/logging.h"
+
 namespace owt {
 namespace base {
 
 CustomizedVideoDecoderProxy::CustomizedVideoDecoderProxy(VideoCodecType type,
   VideoDecoderInterface* external_video_decoder)
-  : codec_type_(type), decoded_image_callback_(nullptr), external_decoder_(external_video_decoder) {}
+  : codec_type_(type), decoded_image_callback_(nullptr), external_decoder_(external_video_decoder),
+  buffer_pool_(false, 300 /* max_number_of_buffers*/){}
 
 CustomizedVideoDecoderProxy::~CustomizedVideoDecoderProxy() {
   if (external_decoder_) {
@@ -23,16 +27,19 @@ int32_t CustomizedVideoDecoderProxy::InitDecode(const webrtc::VideoCodec* codec_
     << "Unsupported codec type" << codec_settings->codecType << " for "
     << codec_type_;
   codec_settings_ = *codec_settings;
+  width_ = codec_settings_.width;
+  height_ = codec_settings_.height;
+  RTC_LOG(LS_ERROR) << "CustomizedVideoDecoderProxy::InitDecode" << width_ << "-" << height_;
   if (external_decoder_) {
-    if (codec_type_ == kVideoCodecH264 && external_decoder_->InitDecodeContext(VideoCodec::kH264)) {
+    if (codec_type_ == kVideoCodecH264 && external_decoder_->InitDecodeContext(VideoCodec::kH264, &width_, &height_)) {
       return WEBRTC_VIDEO_CODEC_OK;
 #ifndef DISABLE_H265
-    } else if (codec_type_ == kVideoCodecH265 && external_decoder_->InitDecodeContext(VideoCodec::kH265)) {
+    } else if (codec_type_ == kVideoCodecH265 && external_decoder_->InitDecodeContext(VideoCodec::kH265, &width_, &height_)) {
       return WEBRTC_VIDEO_CODEC_OK;
 #endif
-    } else if (codec_type_ == kVideoCodecVP8 && external_decoder_->InitDecodeContext(VideoCodec::kVp8)) {
+    } else if (codec_type_ == kVideoCodecVP8 && external_decoder_->InitDecodeContext(VideoCodec::kVp8, &width_, &height_)) {
       return WEBRTC_VIDEO_CODEC_OK;
-    } else if (codec_type_ == kVideoCodecVP9 && external_decoder_->InitDecodeContext(VideoCodec::kVp9)) {
+    } else if (codec_type_ == kVideoCodecVP9 && external_decoder_->InitDecodeContext(VideoCodec::kVp9, &width_, &height_)) {
       return WEBRTC_VIDEO_CODEC_OK;
     }
     return WEBRTC_VIDEO_CODEC_ERROR;
@@ -56,6 +63,33 @@ int32_t CustomizedVideoDecoderProxy::Decode(const EncodedImage& input_image,
   if (external_decoder_) {
     std::unique_ptr<VideoEncodedFrame> frame(new VideoEncodedFrame{input_image.data(), input_image.size(), input_image.Timestamp(), input_image._frameType == webrtc::VideoFrameType::kVideoFrameKey});
     if (external_decoder_->OnEncodedFrame(std::move(frame))) {
+      uint8_t* decoded_frame = external_decoder_->getDecodedFrame(&video_width_, &video_height_);
+      if (decoded_frame == nullptr) { //decode succ , but frame null, just return success
+        return WEBRTC_VIDEO_CODEC_OK;
+      }
+      rtc::scoped_refptr<I420Buffer> buffer = buffer_pool_.CreateBuffer(video_width_, video_height_);
+      if (!buffer.get()) {
+        // Pool has too many pending frames.
+	RTC_LOG(LS_ERROR) <<"CustomizedVideoDecoder to many frame skipped";
+        return WEBRTC_VIDEO_CODEC_NO_OUTPUT;
+      }
+
+      uint8_t *y = decoded_frame;
+      uint8_t *u = y + width_ * height_;
+      uint8_t *v = u + width_ * height_ / 4;
+      libyuv::I420Copy(y, width_,
+                   u, width_ / 2,
+                   v, width_ / 2,
+                   buffer->MutableDataY(), buffer->StrideY(),
+                   buffer->MutableDataU(), buffer->StrideU(),
+                   buffer->MutableDataV(), buffer->StrideV(),
+                   video_width_, video_height_);
+
+      VideoFrame decoded_image = VideoFrame::Builder()
+                                 .set_video_frame_buffer(buffer)
+                                 .set_timestamp_rtp(input_image.Timestamp())
+                                 .build();
+      decoded_image_callback_->Decoded(decoded_image, absl::nullopt, absl::nullopt);
       return WEBRTC_VIDEO_CODEC_OK;
     }
     return WEBRTC_VIDEO_CODEC_ERROR;
@@ -72,6 +106,7 @@ int32_t CustomizedVideoDecoderProxy::RegisterDecodeCompleteCallback(
 int32_t CustomizedVideoDecoderProxy::Release() {
   if (external_decoder_) {
     if (external_decoder_->Release()) {
+      buffer_pool_.Release();
       return WEBRTC_VIDEO_CODEC_OK;
     }
     return WEBRTC_VIDEO_CODEC_ERROR;
diff --git a/talk/owt/sdk/base/customizedvideodecoderproxy.h b/talk/owt/sdk/base/customizedvideodecoderproxy.h
index 0d0ce93..99d3163 100644
--- a/talk/owt/sdk/base/customizedvideodecoderproxy.h
+++ b/talk/owt/sdk/base/customizedvideodecoderproxy.h
@@ -9,6 +9,7 @@
 #include "webrtc/modules/video_coding/include/video_codec_interface.h"
 #include "webrtc/system_wrappers/include/clock.h"
 #include "talk/owt/sdk/include/cpp/owt/base/videodecoderinterface.h"
+#include "common_video/include/i420_buffer_pool.h"
 
 namespace owt {
 namespace base {
@@ -35,6 +36,11 @@ class CustomizedVideoDecoderProxy : public VideoDecoder {
   VideoCodecType codec_type_;
   DecodedImageCallback* decoded_image_callback_;
   VideoDecoderInterface* external_decoder_;
+  I420BufferPool buffer_pool_;
+  int width_;
+  int height_;
+  int video_width_;
+  int video_height_;
 };
 
 } // namespace base
diff --git a/talk/owt/sdk/base/stream.cc b/talk/owt/sdk/base/stream.cc
index d0b5cef..cded323 100644
--- a/talk/owt/sdk/base/stream.cc
+++ b/talk/owt/sdk/base/stream.cc
@@ -197,7 +197,6 @@ void Stream::AttachAudioPlayer(AudioPlayerInterface& player) {
   RTC_LOG(LS_INFO) << "Attached the stream to a renderer.";
 }
 
-#if defined(WEBRTC_WIN)
 void Stream::AttachVideoRenderer(VideoRendererInterface& renderer) {
   if (media_stream_ == nullptr) {
     RTC_LOG(LS_ERROR) << "Cannot attach an audio only stream to a renderer.";
@@ -220,7 +219,6 @@ void Stream::AttachVideoRenderer(VideoRendererInterface& renderer) {
     delete old_renderer;
   RTC_LOG(LS_INFO) << "Attached the stream to a renderer.";
 }
-#endif
 
 #if defined(WEBRTC_LINUX)
 void Stream::AttachVideoRenderer(VideoRendererVaInterface& renderer) {
diff --git a/talk/owt/sdk/include/cpp/owt/base/stream.h b/talk/owt/sdk/include/cpp/owt/base/stream.h
index 256d36f..a6a5da1 100644
--- a/talk/owt/sdk/include/cpp/owt/base/stream.h
+++ b/talk/owt/sdk/include/cpp/owt/base/stream.h
@@ -111,10 +111,8 @@ class OWT_EXPORT Stream {
   /// Attach the stream to an audio player that receives PCM data besides sending to
   /// audio output device.
 #endif
-#if defined(WEBRTC_WIN)
   /// Attach the stream to a Linux VA renderer.
   virtual void AttachVideoRenderer(VideoRendererInterface& renderer);
-#endif
 
 #if defined(WEBRTC_WIN)
   /// Attach the stream to a renderer to receive frames from decoder.
diff --git a/talk/owt/sdk/include/cpp/owt/base/videodecoderinterface.h b/talk/owt/sdk/include/cpp/owt/base/videodecoderinterface.h
index ef88b59..00057ac 100644
--- a/talk/owt/sdk/include/cpp/owt/base/videodecoderinterface.h
+++ b/talk/owt/sdk/include/cpp/owt/base/videodecoderinterface.h
@@ -35,7 +35,7 @@ class VideoDecoderInterface {
    @param video_codec Video codec of the encoded video stream
    @return true if successful or false if failed
    */
-  virtual bool InitDecodeContext(VideoCodec video_codec) = 0;
+  virtual bool InitDecodeContext(VideoCodec video_codeci, int* width, int* height) = 0;
   /**
    @brief This function releases the customized video decoder
    @return true if successful or false if failed
@@ -47,6 +47,13 @@ class VideoDecoderInterface {
    @return true if successful or false if failed
    */
   virtual bool OnEncodedFrame(std::unique_ptr<VideoEncodedFrame> frame) = 0;
+
+  /**
+   @brief This function receives the decoded frame for the further rendering
+   @return Video decoded frame
+   */
+  virtual uint8_t* getDecodedFrame(int *frame_width, int *frame_height) = 0;
+
   /**
    @brief This function generates the customized decoder for each peer connection
    */
-- 
2.25.1

